import mltraq
import numpy as np
from mltraq.experiment import ExperimentAlreadyExists, ExperimentNotFoundException, PickleNotFoundException
from mltraq.run import RunException


def test_unpickle():
    session = mltraq.create_session()
    experiment = session.add_experiment(name="test")

    with experiment.run() as run:
        run.a = 123
        run.locals.b = 123

    experiment.persist(store_pickle=True)
    experiment = session.load(name="test", pickle=True)

    # `a` is not considered when pickling/unpickling runs and experiments
    assert hasattr(experiment, "a") is False

    # `locals` can store variables that are retained thru pickling
    assert experiment.runs.first().locals.b == 123


def test_load_no_pickle():
    session = mltraq.create_session()
    experiment = session.add_experiment(name="test")

    with experiment.run() as run:
        run.a = 123
        run.locals.b = 123

    experiment.persist()
    experiment = session.load(name="test")

    # `a` is not considered when pickling/unpickling runs and experiments
    assert hasattr(experiment, "a") is False

    # locals not preserved
    assert hasattr(experiment.runs.first().locals, "b") is False


def test_experiment_Runs():
    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.add_runs(a=[1, 2, 3])
    assert len(e.runs) == 3


def test_experiment_Run():
    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.add_run(a=123)
    assert e.runs.first().params.a == 123


def test_experiment_empty():
    s = mltraq.create_session()

    e = s.add_experiment("test")
    e.execute()

    # If no runs are added, a dummy one is generated by default if we
    # execute it.
    assert len(e.runs) == 1

    df = e.df()

    # A frame representing an empty experiment contains only two columns: id_experiment and name.
    # Further, its only property of an empty experiment is "env".

    assert str(df.to_dict()) == "{'id_experiment': {0: '" + str(df.id_experiment.iloc[0]) + "'}, 'name': {0: 'test'}}"

    assert list(s.add_experiment("name").properties.keys()) == []


def test_experiment_empty_persist():
    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.persist(if_exists="replace")


def test_experiment_simple():
    s = mltraq.create_session()

    def f1(run: mltraq.Run):
        run.fields.result1 = run.params.data + run.kwargs["inc"]

    def f2(run: mltraq.Run):
        run.fields.result2 = run.params.data + run.kwargs["inc"] * 2

    e = s.add_experiment("test")
    e.add_runs(data=[100, 200, 300])
    e.execute(steps=[f1, f2], kwargs={"inc": 5}, n_jobs=1)

    assert e.runs.df()["result1"].sort_values().tolist() == [105, 205, 305]
    assert e.runs.df()["result2"].sort_values().tolist() == [110, 210, 310]


def test_experiment_simple2():
    def f1(run: mltraq.Run):
        run.fields.result1 = run.params.data + run.kwargs["inc"]

    def f2(run: mltraq.Run):
        run.fields.result2 = run.params.data + run.kwargs["inc"] * 2

    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.add_runs(data=[100, 200, 300])

    e.execute(kwargs={"inc": 5}, steps=[f1, f2])

    assert e.runs.df()["result1"].sort_values().tolist() == [105, 205, 305]
    assert e.runs.df()["result2"].sort_values().tolist() == [110, 210, 310]


def test_experiment_biased_coin():
    def toss_coin(run: mltraq.Run):
        run.fields.P = run.params.P
        run.fields.N = run.kwargs.N

        for i in range(run.kwargs.N):
            if i == 0:
                run.fields.p_head = 0
            elif i == run.kwargs.N - 1:
                run.fields.p_head /= run.kwargs.N
            else:
                run.fields.p_head += 1 if np.random.random() < run.params.P else 0

    s = mltraq.create_session()
    e = s.add_experiment("biased_coin")
    e.add_runs(P=[0.4, 0.5, 0.6])
    e.execute(kwargs={"N": 1000}, steps=toss_coin, n_jobs=1)
    assert len(e.runs.df()) == 3


def test_experiment_nested():
    s = mltraq.create_session()

    def f(run: mltraq.Run):
        run.fields.x = {"a": 1, "b": 2}
        run.fields.y = {"a": {"b": 1}}

    e = s.add_experiment("test")
    e.add_runs(data=[100])
    e.execute(steps=f)

    assert e.runs.df().columns.tolist() == ["id_run", "x", "y"]
    assert e.runs.df().iloc[0].y["a"]["b"] == 1


def test_experiment_many():
    s = mltraq.create_session()

    def f1(run: mltraq.Run):
        run.fields.params = run.params
        run.fields.result1 = run.params.data + run.kwargs["inc"]

    def f2(run: mltraq.Run):
        run.fields.result2 = run.params.data + run.kwargs["inc"] * 2

    e = s.add_experiment("test")
    e.add_runs(data=range(2001))
    e.execute(steps=[f1, f2], kwargs={"inc": 5})

    e.persist()

    assert s.query("select count(*) as count_rows from e_test").count_rows.iloc[0] == 2001


def test_experiment_replace():
    s = mltraq.create_session()

    def f(run: mltraq.Run):
        run.fields.a = run.kwargs.a

    e = s.add_experiment("test")
    e.add_runs(data=range(10))

    e.execute(steps=f, kwargs={"a": 123}).persist()
    assert s.query("SELECT a from e_test")["a"].iloc[0] == 123

    try:
        e.execute(steps=f, kwargs={"a": 124}).persist()
    except ExperimentAlreadyExists:
        assert s.query("SELECT a from e_test")["a"].iloc[0] == 123

    e.execute(steps=f, kwargs={"a": 124}).persist(if_exists="replace")
    assert s.query("SELECT a from e_test")["a"].iloc[0] == 124


def test_copy():
    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.add_runs(data=range(10))

    e2 = e.copy()
    assert len(e.runs) == 10
    assert len(e2.runs) == 10
    assert e.runs.first() != e2.runs.first()


def test_sql_query():
    # Let's also disable tqdm for this test
    with mltraq.options.option_context({"tqdm.disable": True}):
        s = mltraq.create_session()

        def f(run: mltraq.Run):
            run.fields.result1 = run.params.data + run.kwargs["inc"]
            run.fields.result2 = run.params.data + run.kwargs["inc"] * 2

        e = s.add_experiment("test")
        e.add_runs(data=[100, 200, 300])

        # Execute experiment
        e.execute(steps=f, kwargs={"inc": 5})

        # Before querying an experiment with SQL, we must store it in the db
        e.persist()

        assert e.query("select result1 from {experiment} order by result1 asc")["result1"].tolist() == [105, 205, 305]


def test_experiment_run_auto():
    s = mltraq.create_session()

    def f(run):
        run.fields.a = 123

    e = s.add_experiment(name="test")
    e.add_runs()
    e.execute(steps=f)

    df = e.runs.df()

    assert str(df.to_dict()) == "{'id_run': {0: '" + str(df.id_run.iloc[0]) + "'}, 'a': {0: 123}}"


def test_experiment_run_context():
    s = mltraq.create_session()

    e = s.add_experiment(name="test")

    with e.run() as run:
        run.fields.a = 123

    df = e.runs.df()

    assert str(df.to_dict()) == "{'id_run': {0: '" + str(df.id_run.iloc[0]) + "'}, 'a': {0: 123}}"


def test_experiment_run_explicit():
    s = mltraq.create_session()

    e = s.add_experiment(name="test")

    run = mltraq.Run()
    run.fields.a = 123

    e.runs[run.id_run] = run

    df = e.runs.df()

    assert str(df.to_dict()) == "{'id_run': {0: '" + str(df.id_run.iloc[0]) + "'}, 'a': {0: 123}}"


def test_experiment_basic():
    # Connect to a MLTRAQ session and create an experiment.
    session = mltraq.create_session()
    experiment = session.add_experiment("honey")

    # Instantiate a new run and track metrics.
    run = experiment.runs.next()
    run["accuracy"] = 0.87

    # Instantiate a new run using the context manager for cleaner code.
    with experiment.run() as run:
        run["accuracy"] = 0.95

    # Persist experiment to database and query it with SQL.
    experiment.persist()
    assert session.query("SELECT accuracy FROM e_honey").accuracy.tolist() == [0.87, 0.95]


def test_experiment_exception():
    def f(run: mltraq.Run):
        if run.params.data == 300:
            raise Exception("error 123")

    s = mltraq.create_session()
    e = s.add_experiment("test")

    e.add_runs(data=[100, 200, 300])

    message = ""
    try:
        e.execute(steps=f)
    except RunException as ex:
        message = ex.message
    assert 'raise Exception("error 123")"' in message

    message = ""
    try:
        e.execute(steps=f, n_jobs=1)
    except RunException as ex:
        message = ex.message
    assert 'raise Exception("error 123")"' in message


def test_experiment_re_execute():
    def f(run: mltraq.Run):
        run.fields.a = 0
        if run.params.value == 100:
            raise Exception("error 123")
        run.fields.a += 1

    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.add_runs(data=[100, 200, 300])

    try:
        e.execute(steps=f)
    except RunException:
        # The error caused by data=100 triggered the exception, and
        # all runs haven't been updated.
        pass

    # `a` is not set, as the outcome of f(...) was dropped for successful runs
    assert e.runs.df().columns.tolist() == ["id_run"]

    # we now execute again, setting `a` to 1
    def f(run: mltraq.Run):
        run.fields.a = 1

    e.execute(steps=f)

    for run in e.runs.values():
        # all runs are executed, and all of them have a=1.
        assert run.fields.a == 1


def test_info():
    s = mltraq.create_session()
    e = s.add_experiment("test")
    e.add_runs(a=[100, 200, 300])

    def f(run: mltraq.Run):
        run.fields.b = 123

    e.execute(steps=f)

    s = e.info()

    assert s.run_count == 3
    assert s.run_params == ["a"]
    assert s.run_fields == ["b"]


def test_info_empty():
    s = mltraq.create_session()
    e = s.add_experiment("test")

    s = e.info()

    assert s.run_count == 0


def test_ExperimentNotFoundException():
    session = mltraq.create_session()
    experiment = session.add_experiment(name="test")

    with experiment.run() as run:
        run.a = 123
        run.locals.b = 123

    experiment.persist(store_pickle=True)

    try:
        experiment = session.load(name="test2", pickle=True)
    except ExperimentNotFoundException:
        return

    raise Exception("ExperimentNotFoundException not raised")


def test_ExperimentNotFoundException():
    session = mltraq.create_session()
    experiment = session.add_experiment(name="test")

    with experiment.run() as run:
        run.a = 123
        run.locals.b = 123

    experiment.persist(store_pickle=False)

    try:
        experiment = session.load(name="test", pickle=True)
    except PickleNotFoundException:
        return

    raise Exception("PickleNotFoundException not raised")
